<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stroop Test â€” Export</title>

<!-- Inter font - same as gng-export -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

<style>
  :root {
    --font-family: 'Inter', sans-serif;
    --border-radius: 8px;
    --transition-speed: 0.28s;

    /* Dark Theme (match gng-export) */
    --bg-color: #121212;
    --text-color: #E0E0E0;
    --sidebar-bg: #1E1E1E;
    --sidebar-border: #333;
    --input-bg: #2C2C2C;
    --input-border: #444;
    --input-text: #E0E0E0;
    --button-bg: #333;
    --button-text: #E0E0E0;
    --accent-color: #3B82F6;
    --shadow-color: rgba(0,0,0,0.22);
  }

  body.light {
    --bg-color: #F4F4F5;
    --text-color: #18181B;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E4E4E7;
    --input-bg: #FFFFFF;
    --input-border: #D4D4D8;
    --input-text: #18181B;
    --button-bg: #E4E4E7;
    --button-text: #18181B;
    --accent-color: #2563EB;
    --shadow-color: rgba(0, 0, 0, 0.10);
  }

  html,body{height:100%;margin:0;font-family:var(--font-family);background:var(--bg-color);color:var(--text-color);}
  body {transition: background var(--transition-speed) ease, color var(--transition-speed) ease;}

  /* Layout like gng-export: sidebar + main */
  .container {display:flex;height:100vh;gap:0;}
  #sidebar {
    width:300px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:22px;
    box-sizing:border-box;
    border-right:1px solid var(--sidebar-border);
    box-shadow: 2px 0 18px var(--shadow-color);
    overflow:auto;
  }
  #sidebar h2{margin:0 0 12px 0;font-size:22px;color:var(--accent-color)}
  label{display:block;font-size:13px;margin:10px 0 6px;color:var(--input-text)}
  input[type="text"], input[type="number"], select {
    width:100%;padding:10px;border-radius:10px;border:1px solid var(--input-border);background:var(--input-bg);color:var(--input-text);box-sizing: border-box;
  }
  input[type="range"]{width:100%}
  .row{display:flex;gap:8px}
  .btn{padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:var(--button-bg);color:var(--button-text);cursor:pointer;}
  .btn.primary{background:linear-gradient(180deg,var(--accent-color),#2563eb);color:#fff;font-weight:600;border-color:transparent}
  .muted{color:rgb(from var(--button-text) r g b / 0.5);font-size:14px}

  /* advanced config box */
  details.advanced-config{margin-top:12px;border:1px solid var(--input-border);border-radius:10px;padding:6px;background:transparent}
  details.advanced-config summary{outline:none;padding:8px;cursor:pointer}

  /* Main */
  #main {flex:1;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:28px;gap:12px}
  #title {font-size:20px;margin:0;align-self:flex-start;color:var(--text-color)}
  .instructions {
    width:100%;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:12px;
    box-shadow:0 8px 30px rgba(2,6,23,0.5);
  }
  .instructions h3{margin:0 0 8px 0}
  .instructions p{margin:6px 0;color:var(--muted);line-height:1.5}
  /* ensure instruction text colors are static and not tied to stimulus color */

  .stage {
    width:min(980px,100%); display:flex;flex-direction:column;align-items:center;gap:12px;margin-top:6px;
  }

  .stimulus {
    width:100%;height:260px;border-radius:14px;display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow:0 8px 30px rgba(2,6,23,0.5);
    font-size:58px;font-weight:700;user-select:none;position:relative;overflow:hidden;
  }

  .stimulus .word {
    display:inline-block;will-change:transform; /* transition:transform .12s linear; */
  }

  .controls {display:flex;gap:10px;align-items:center}
  .keybar{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-top:6px}
  .key {
    display:flex;flex-direction:column;align-items:center;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);
    min-width:88px;cursor:default;box-shadow:0 6px 18px rgba(2,6,23,0.4);transition:transform .08s,box-shadow .08s;
  }
  .key .kbd{font-size:13px;padding:6px 8px;border-radius:6px;background:rgba(0,0,0,0.12);margin-bottom:8px}
  .key .colname{font-weight:700}

  .key.pressed{transform:translateY(-3px);box-shadow:0 14px 30px rgba(2,6,23,0.55)}

  /* Results popup & PDF modal (match gng-export) */
  #popup, #instructions-overlay {position:fixed;top:0;left:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);backdrop-filter:blur(4px);z-index:90}
  .popup-card{background:var(--sidebar-bg);padding:18px;border-radius:14px;max-width:1100px;width:94%;box-shadow:0 14px 40px rgba(0,0,0,0.6)}
  canvas{background:#fff;border-radius:8px;display:block;margin:12px auto}

  /* alert */
  #modernAlert {position:fixed;top:-120px;left:50%;transform:translateX(-50%);background:#ff4757;color:white;padding:12px 22px;border-radius:8px;z-index:9999;transition:top .4s}
  #modernAlert.show{top:18px}
    /* --- Misc & Utility --- */
#modeToggle {
    position: absolute;
    top: 15px;
    right: 15px;
    cursor: pointer;
    background: var(--button-bg);
    color: var(--button-text);
    padding: 8px 12px;
    border-radius: var(--border-radius);
    font-size: 20px;
}
    #instructions {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(5px); /* Glassmorphism effect */
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 1000;
      /* opacity: 0; */
      animation: fadeIn 0.3s forwards;
    }
    #instructions {
        display: flex; /* Override none to show initially */
        padding: 40px;
        box-sizing: border-box;
    }

    #popupContent, #instructions div {
      background: var(--sidebar-bg);
      padding: 30px;
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      max-width: 650px;
      width: 90%;
    }
    
    #instructions div {
        text-align: left;
        line-height: 1.7;
    }
  /* responsive */
  @media (max-width:900px){#sidebar{display:none} .container{flex-direction:column} #main{padding:12px}}
</style>
</head>
<body>
<div id="modernAlert"><p id="modernAlertMessage" style="margin:0"></p></div>

<div class="container">
  <aside id="sidebar" aria-label="Configuration">
    <h2>Config</h2>

    <label>Subject ID (required)</label>
    <input id="subjectId" type="text" placeholder="Enter Subject ID">

    <label>Age</label>
    <input id="subjectAge" type="number" placeholder="Enter Age">

    <label>Sex</label>
    <select id="subjectSex">
      <option value="">Select Sex</option>
      <option>Male</option><option>Female</option><option>Other</option>
    </select>

    <label>NUM_TRIALS</label>
    <input id="numTrials" type="number" value="30" min="4">

    <details class="advanced-config">
      <summary>Advanced Config</summary>
      <div style="padding:10px">
        <label>STIMULUS_TIME (ms)</label>
        <input id="stimTime" type="number" value="1500">
        <label>ISI (ms)</label>
        <input id="isi" type="number" value="800">
        <label>Match % (word == ink)</label>
        <input id="matchPct" type="range" min="0" max="100" value="50">
        <div class="muted" style="margin-top:4px">Match: <span id="matchPctLabel">50%</span></div>
      </div>
    </details>

    <label>Respond To</label>
    <select id="respondTo">
      <option value="color">Color (ink)</option>
      <option value="word">Word (text)</option>
    </select>

    <label>Number of colors</label>
    <select id="numColors">
      <option value="2">2</option>
      <option value="3" selected>3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
    </select>

    <label>Orientation (multiples of 45Â°)</label>
    <select id="orientation">
      <option value="0">0Â°</option>
      <option value="45">45Â°</option>
      <option value="90">90Â°</option>
      <option value="135">135Â°</option>
      <option value="180">180Â°</option>
      <option value="225">225Â°</option>
      <option value="270">270Â°</option>
      <option value="315">315Â°</option>
      <option value="random" selected>Random (45Â° multiples)</option>
    </select>

    <div style="margin-top:12px" class="row">
      <button id="openBindings" class="btn">Bindings</button>
      <button id="loadDefaults" class="btn">Load Defaults</button>
    </div>

    <div style="margin-top:12px" class="row">
      <button id="startBtn" class="btn primary">Start Test</button>
      <button id="restartBtn" class="btn">Reset</button>
    </div>

    <!-- <div style="margin-top:14px" class="muted">Tip: Open Bindings â†’ click a color row â†’ press desired key â†’ Enter to save.</div> -->
  </aside>

  <main id="main">
    <div id="title">Stroop Test</div>




    <div class="stage">
      <div id="status" class="muted">Ready. Configure parameters and press Start Test.</div>

      <div class="stimulus" id="stimulus" role="status" aria-live="polite">
        <div class="word" id="stimWord">â€”</div>
      </div>

      <div class="keybar" id="keybar"></div>

      <div id="resultsSummary" style="width:100%;max-width:980px;display:none;margin-top:8px"></div>
      <button id="modeToggle">ðŸŒ™</button>
    </div>
  </main>
</div>

<!-- Bindings modal -->
<div id="bindingsModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);align-items:center;justify-content:center;z-index:200">
  <div style="background:var(--sidebar-bg);padding:16px;border-radius:12px;width:460px;box-shadow:0 10px 30px rgba(0,0,0,0.4)">
    <h3 style="margin-top:0">Key Bindings</h3>
    <div class="muted" style="margin-bottom:8px">Click a row, press the key you want, then press Enter to confirm. Escape cancels.</div>
    <div id="bindingsList" style="display:flex;flex-direction:column;gap:8px;max-height:320px;overflow:auto"></div>

    <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
      <button id="closeBindings" class="btn">Close</button>
    </div>
  </div>
</div>

<!-- Popup for report -->
<div id="popup" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:95">
  <div class="popup-card">
    <h2 style="margin-top:0">Stroop Test Report</h2>
    <div style="display:flex;gap:12px;flex-wrap:wrap">
      <canvas id="rtChart" width="480" height="240"></canvas>
      <canvas id="accChart" width="480" height="240"></canvas>
      <canvas id="countsChart" width="480" height="240"></canvas>
    </div>

    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
      <button id="csvBtn" class="btn">Download CSV</button>
      <button id="pdfBtn" class="btn">Download PDF</button>
      <button id="closePopup" class="btn">Close</button>
    </div>
  </div>
</div>
    <!-- Instructions overlay -->
<div id="instructions">
  <div>
    <h2>Welcome to the Stroop Test</h2>
    <p>
      In this test, you will see <b>color words</b> (like "RED", "GREEN", "BLUE") displayed in different ink colors.<br><br>
      - If the task is set to <b>Respond to Color</b> â†’ press the key mapped to the ink color.<br>
      - If the task is set to <b>Respond to Word</b> â†’ press the key mapped to the written word.<br><br>
      Stimuli may appear rotated (multiples of 45Â°) depending on your config.<br><br>
      Your performance will be scored on:<br>
      - Reaction times<br>
      - Correct responses<br>
      - Omissions (missed responses)<br>
      - Commissions (wrong responses)<br><br>
    </p>
    <button class="btn primary" onclick="hideInstructions()" autofocus>Continue</button>
  </div>
</div>
<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>

<script>

/* Stroop Export - cloned UI from gng-export with stroop logic
   - orientation multiples of 45Â° with random option
   - bindings modal for key assignments
   - CSV + PDF report using Chart.js + jsPDF
*/
function hideInstructions() {
  document.getElementById("instructions").style.display = "none";
//   document.getElementById("startBtn").style.display = "inline-block";
  document.getElementById('subjectId').focus();
}

window.addEventListener("load", () => {
  document.querySelectorAll("#sidebar input, #sidebar select").forEach(el => {
    if (["subjectId","subjectAge","subjectSex"].includes(el.id)) return; // skip
    if (localStorage[el.id]) el.value = localStorage[el.id];
    el.addEventListener("change", () => {
      if (!["subjectId","subjectAge","subjectSex"].includes(el.id)) {
        localStorage[el.id] = el.value;
      }
    });
  });
});

// subject fields always blank on refresh
document.getElementById('subjectId').value = '';
document.getElementById('subjectAge').value = '';
document.getElementById('subjectSex').value = '';
document.getElementById('numColors').value =  '3';


(() => {
  // palette (same as gng-export - choose top N)
  const ALL_COLORS = [
    {name:'RED', css:'#ef4444'},
    {name:'GREEN', css:'#10b981'},
    {name:'BLUE', css:'#3b82f6'},
    {name:'YELLOW', css:'#f59e0b'},
    {name:'PURPLE', css:'#8b5cf6'},
    {name:'BROWN', css:'#af623a'},
    {name:'ORANGE', css:'#fb923c'}
  ];

  // DOM refs
  const subjectIdEl = document.getElementById('subjectId');
  const subjectAgeEl = document.getElementById('subjectAge');
  const subjectSexEl = document.getElementById('subjectSex');
  const numTrialsEl = document.getElementById('numTrials');
  const stimTimeEl = document.getElementById('stimTime');
  const isiEl = document.getElementById('isi');
  const matchPctEl = document.getElementById('matchPct');
  const matchPctLabel = document.getElementById('matchPctLabel');
  const respondToEl = document.getElementById('respondTo');
  const numColorsEl = document.getElementById('numColors');
  const orientationEl = document.getElementById('orientation');
  const openBindingsBtn = document.getElementById('openBindings');
  const bindingsModal = document.getElementById('bindingsModal');
  const bindingsList = document.getElementById('bindingsList');
  const closeBindingsBtn = document.getElementById('closeBindings');
  const loadDefaultsBtn = document.getElementById('loadDefaults');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const statusEl = document.getElementById('status');
  const stimEl = document.getElementById('stimulus');
  const stimWordEl = document.getElementById('stimWord');
  const keybarEl = document.getElementById('keybar');
  const resultsSummaryEl = document.getElementById('resultsSummary');
  const popup = document.getElementById('popup');
  const closePopupBtn = document.getElementById('closePopup');
  const csvBtn = document.getElementById('csvBtn');
  const pdfBtn = document.getElementById('pdfBtn');
  const rtCanvas = document.getElementById('rtChart');
  const accCanvas = document.getElementById('accChart');
  const countsCanvas = document.getElementById('countsChart');
  const modernAlert = document.getElementById('modernAlert');
  const modernAlertMessage = document.getElementById('modernAlertMessage');
  const modeToggle = document.getElementById("modeToggle");

  // state
  let bindings = {}; // colorName -> key (lowercase)
  let trials = [];
  let currentIndex = -1;
  let awaitingResponse = false;
  let stimulusShownAt = 0;
  let stimTimeout = null;
  let isiTimeout = null;
  let results = []; // per-trial records
  let lastCapturedKey = null;
  let currentBindingCapture = null;
  let rtChart = null;
  let accChart = null;
  let countsChart = null;

  // helpers: luminance to decide text color (black/white)
  function luminance(hex){
    const h = hex.replace('#','');
    const r = parseInt(h.slice(0,2),16)/255;
    const g = parseInt(h.slice(2,4),16)/255;
    const b = parseInt(h.slice(4,6),16)/255;
    const a = [r,g,b].map(v => v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055,2.4));
    return 0.2126*a[0] + 0.7152*a[1] + 0.0722*a[2];
  }
  function contrastTextColor(hex){ return luminance(hex) > 0.179 ? '#000' : '#fff'; }

  // alert
  let alertTimeout = null;
  function showAlert(msg){
    modernAlertMessage.textContent = msg;
    modernAlert.classList.add('show');
    clearTimeout(alertTimeout);
    alertTimeout = setTimeout(()=> modernAlert.classList.remove('show'), 3000);
  }

  // default bindings loader
  function loadDefaultBindings(n){
    const keys = ['s','d','f','j','k','l','g'];
    bindings = {};
    const sel = ALL_COLORS.slice(0,n);
    sel.forEach((c,i) => bindings[c.name] = keys[i] || String(i+1));
    rebuildKeybar();
  }

  // render keybar
  function rebuildKeybar(){
    keybarEl.innerHTML = '';
    const n = parseInt(numColorsEl.value,10);
    const colors = ALL_COLORS.slice(0,n);
    colors.forEach(c => {
      const el = document.createElement('div');
      el.className = 'key';
      el.dataset.color = c.name;
      // inner
      const kd = document.createElement('div'); kd.className='kbd'; kd.textContent = (bindings[c.name] || '-').toUpperCase();
      const cn = document.createElement('div'); cn.className='colname'; cn.textContent = c.name;
      cn.style.background = c.css;
      cn.style.color = contrastTextColor(c.css);
      cn.style.padding = '6px 10px';
      cn.style.borderRadius = '8px';
      el.appendChild(kd); el.appendChild(cn);
      keybarEl.appendChild(el);
    });
  }

  // bindings modal render
  function renderBindingsList(){
    bindingsList.innerHTML = '';
    const n = parseInt(numColorsEl.value,10);
    const colors = ALL_COLORS.slice(0,n);
    colors.forEach(c => {
      const row = document.createElement('div');
      row.style.display='flex';row.style.justifyContent='space-between';row.style.alignItems='center';
      row.style.padding='8px';row.style.borderRadius='8px';row.style.background='rgba(255,255,255,0.01)';
      const left = document.createElement('div'); left.style.display='flex';left.style.alignItems='center';left.style.gap='10px';
      const sw = document.createElement('div'); sw.style.width='28px';sw.style.height='20px';sw.style.background=c.css;sw.style.borderRadius='6px';
      const lbl = document.createElement('div'); lbl.innerHTML=`<strong>${c.name}</strong><div class="muted" style="font-size:12px">${c.css}</div>`;
      left.appendChild(sw); left.appendChild(lbl);
      const right = document.createElement('div'); right.style.display='flex';right.style.alignItems='center';right.style.gap='8px';
      const keyDisplay = document.createElement('div'); keyDisplay.style.minWidth='80px'; keyDisplay.style.padding='6px 8px'; keyDisplay.style.borderRadius='8px';
      keyDisplay.style.background='rgba(0,0,0,0.08)'; keyDisplay.textContent = (bindings[c.name]||'[not set]').toUpperCase();
      const setBtn = document.createElement('button'); setBtn.className='btn'; setBtn.textContent='Set';
      setBtn.onclick = () => {
        currentBindingCapture = c.name;
        lastCapturedKey = null;
        // show temporary change
        keyDisplay.textContent = 'Press key â†’ Enter';
        keyDisplay.style.background='rgba(16,185,129,0.08)';
        keyDisplay.style.fontWeight='700';
        // focus to document for key capture
      };
      right.appendChild(keyDisplay); right.appendChild(setBtn);
      row.appendChild(left); row.appendChild(right);
      bindingsList.appendChild(row);
    });
  }

  // normalize key
  function normKey(k){
    if(!k) return '';
    if(k.length === 1) return k.toLowerCase();
    return k.toLowerCase();
  }

  // generate trials
  function generateTrials(){
    const N = Math.max(1, parseInt(numTrialsEl.value,10) || 30);
    const nColors = Math.max(2, Math.min(ALL_COLORS.length, parseInt(numColorsEl.value,10)));
    const matchPct = parseInt(matchPctEl.value,10);
    const colors = ALL_COLORS.slice(0,nColors);
    const orientOpt = orientationEl.value; // 'random' or degree
    const trialsArr = [];
    for(let i=0;i<N;i++){
      const isMatch = Math.random()*100 < matchPct;
      // pick displayed word (a color name) and ink color
      let wordObj = colors[Math.floor(Math.random()*colors.length)];
      let inkObj;
      if(isMatch){
        inkObj = wordObj;
      } else {
        const others = colors.filter(c=>c.name!==wordObj.name);
        inkObj = others[Math.floor(Math.random()*others.length)];
      }
      // orientation
      let angle = 0;
      if(orientOpt === 'random'){
        const multiples = [0,45,90,135,180,225,270,315];
        angle = multiples[Math.floor(Math.random()*multiples.length)];
      } else {
        angle = parseInt(orientOpt,10) || 0;
      }
      // saved
      trialsArr.push({
        idx: i+1,
        word: wordObj.name,
        wordCSS: wordObj.css,
        ink: inkObj.name,
        inkCSS: inkObj.css,
        isMatch,
        angle
      });
    }
    return trialsArr;
  }

  // show stimulus
  function showStim(tr){
    stimWordEl.textContent = tr.word;
    stimWordEl.style.color = tr.inkCSS;
    stimWordEl.style.transform = `rotate(${tr.angle}deg)`;
    // center and style
    stimulusShownAt = performance.now();
    awaitingResponse = true;
    // set timeout for omission
    stimTimeout = setTimeout(()=>{
      if(awaitingResponse){
        awaitingResponse = false;
        // omission
        results.push({
          trial: tr.idx,
          word: tr.word,
          ink: tr.ink,
          angle: tr.angle,
          keyPressed: '',
          correctKey: bindings[(respondToEl.value === 'color') ? tr.ink : tr.word] || '',
          correct: 0,
          RT: ''
        });
        // show missed briefly
        stimWordEl.textContent = 'Missed';
        stimWordEl.style.color = '#ef4444';
        setTimeout(()=>{ stimWordEl.textContent=''; }, 220);
        isiTimeout = setTimeout(()=> nextTrial(), parseInt(isiEl.value,10));
      }
    }, parseInt(stimTimeEl.value,10));
  }

  // next trial
  function nextTrial(){
    currentIndex++;
    clearTimeout(stimTimeout); clearTimeout(isiTimeout);
    stimWordEl.style.transform = 'rotate(0deg)';
    stimWordEl.style.color = 'var(--muted)';
    if(currentIndex >= trials.length){
      endTest();
      return;
    }
    const tr = trials[currentIndex];
    statusEl.textContent = `Trial ${currentIndex+1} / ${trials.length}`;
    // small blank then show
    setTimeout(()=> showStim(tr), 120);
  }

  // handle response (key press)
  function handleResponseKey(key){
    key = normKey(key);
    if(!awaitingResponse) return;
    awaitingResponse = false;
    clearTimeout(stimTimeout);
    const tr = trials[currentIndex];
    const rt = Math.round(performance.now() - stimulusShownAt);
    const expectedName = (respondToEl.value === 'color') ? tr.ink : tr.word;
    const correctKey = (bindings[expectedName] || '').toLowerCase();
    const pressedIsCorrect = (key === correctKey);
    // find pressed color(s) if any
    // add result
    results.push({
      trial: tr.idx,
      word: tr.word,
      ink: tr.ink,
      angle: tr.angle,
      keyPressed: key || '',
      correctKey: correctKey || '',
      correct: pressedIsCorrect ? 1 : 0,
      RT: pressedIsCorrect ? rt : rt
    });

    // visual flash on keybar
    highlightKeyByKey(key);

    // feedback effects
    if(pressedIsCorrect){
      stimWordEl.style.boxShadow = '0 8px 40px rgba(16,185,129,0.18)';
    } else {
      stimWordEl.style.boxShadow = '0 8px 40px rgba(239,68,68,0.18)';
      beep(400,160);
    }
    setTimeout(()=> stimWordEl.style.boxShadow = '', 160);

    // proceed after ISI
    isiTimeout = setTimeout(()=> nextTrial(), parseInt(isiEl.value,10));
  }

  // highlight keybar element by pressed key string
  function highlightKeyByKey(k){
    const pressKeys = Object.keys(bindings).filter(n => (bindings[n]||'').toLowerCase() === k);
    Array.from(keybarEl.children).forEach(el=>{
      el.classList.remove('pressed');
      if(pressKeys.includes(el.dataset.color)){
        el.classList.add('pressed');
        setTimeout(()=> el.classList.remove('pressed'), 220);
      }
    });
  }

  // start test
  function startTest(){
    // validate subject info
    const sid = subjectIdEl.value.trim();
    if(!sid){ showAlert('Subject ID is required'); return; }
    if(!subjectAgeEl.value){ showAlert('Age is required'); return; }
    if(!subjectSexEl.value){ showAlert('Sex is required'); return; }

    // validate bindings
    const neededColors = ALL_COLORS.slice(0, parseInt(numColorsEl.value,10)).map(c=>c.name);
    const missing = neededColors.filter(c=>!(bindings[c]));
    if(missing.length){
      showAlert('Please set key bindings for all colors before starting.');
      openBindings();
      return;
    }

    // reset
    results = []; currentIndex = -1;
    trials = generateTrials();

    // small countdown like gng-export (3..1)
    let count = 3; statusEl.textContent = count;
    startBtn.disabled = true;
    const cd = setInterval(()=>{
      count--;
      if(count<=0){
        clearInterval(cd);
        statusEl.textContent = 'Running...';
        nextTrial();
      } else { statusEl.textContent = count; }
    },1000);
  }

  function endTest(){
    startBtn.disabled = false;
    statusEl.textContent = 'Finished';
    stimWordEl.textContent = 'â€”';
    // show summary
    showSummary();
    // enable popup/report button
    popup.style.display = 'flex';
    popup.style.alignItems = 'center';
    popup.style.justifyContent = 'center';
    // Render charts
    renderCharts();
  }

  // show summary on page
  function showSummary(){
    const correctCount = results.filter(r=>r.correct).length;
    const omissions = results.filter(r=>r.keyPressed === '').length;
    const commissions = results.filter(r=>r.keyPressed && !r.correct).length;
    const rtList = results.filter(r=>r.RT).map(r=>Number(r.RT));
    const meanRT = rtList.length ? Math.round(rtList.reduce((a,b)=>a+b,0)/rtList.length) : '-';
    resultsSummaryEl.style.display = 'block';
    resultsSummaryEl.innerHTML = `
      <div style="background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:10px">
        <strong>Summary</strong>
        <div class="muted">Trials: ${results.length}</div>
        <div>Mean RT (correct): <strong>${meanRT} ms</strong></div>
        <div>Correct: <strong>${correctCount}</strong> | Omissions: <strong>${omissions}</strong> | Commissions: <strong>${commissions}</strong></div>
      </div>
    `;
  }

    // Dark/Light mode toggle
    modeToggle.addEventListener("click", () => {
      document.body.classList.toggle("light");
      modeToggle.textContent = document.body.classList.contains("light") ? "ðŸŒž" : "ðŸŒ™";
    });
  // CSV download
  function downloadCSV(){
    if(results.length === 0){ showAlert('No results to export'); return; }
    const sid = subjectIdEl.value.trim() || 'subject';
    const hdr = ['trial','word','ink','angle','keyPressed','correctKey','correct','RT'];
    const rows = [hdr.join(',')];
    for(const r of results){
      const vals = hdr.map(h => {
        const v = (r[h] === undefined || r[h] === null) ? '' : String(r[h]);
        return v.includes(',') || v.includes('"') ? `"${v.replace(/"/g,'""')}"` : v;
      }).join(',');
      rows.push(vals);
    }
    // add metadata at top
    const meta = [
      `Subject ID,${sid}`,
      `Age,${subjectAgeEl.value||''}`,
      `Sex,${subjectSexEl.value||''}`,
      `NUM_TRIALS,${numTrialsEl.value}`,
      `STIMULUS_TIME,${stimTimeEl.value}`,
      `ISI,${isiEl.value}`,
      `MatchPct,${matchPctEl.value}`,
      `NUM_COLORS,${numColorsEl.value}`,
      `RespondTo,${respondToEl.value}`,
      `Orientation,${orientationEl.value}`,
    ].join('\n');
    const csv = meta + '\n\n' + rows.join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
    a.download = `${sid}_stroop_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(a.href);
  }

  // PDF generation using jsPDF - two pages: cover + charts
 async function downloadPDF() {
    if (results.length === 0) {
        showAlert('No results to export');
        return;
    }
    await renderCharts(true); // Ensure charts are ready

    const { jsPDF } = window.jspdf;
    // Initialize PDF in A4 size with mm as units
    const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4'
    });

    // --- 1. Layout & Page Setup ---
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 15;
    const gutter = 10; // Space between columns
    const colWidth = (pageWidth - (margin * 2) - gutter) / 2;
    const col1_x = margin;
    const col2_x = margin + colWidth + gutter;
    let y = 0; // Global Y-position tracker

    // --- 2. Report Header ---
    const now = new Date();
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(18);
    pdf.text('Stroop Test Report', pageWidth / 2, 20, { align: 'center' });

    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(9);
    pdf.setTextColor(100);
    pdf.text(`Generated on: ${now.toLocaleString()}`, pageWidth / 2, 27, { align: 'center' });

    pdf.setLineWidth(0.5);
    pdf.line(margin, 32, pageWidth - margin, 32);

    // Set starting Y position for columns
    y = 40;
    let y_col1 = y;
    let y_col2 = y;

    // --- 3. Left Column (Test Data) ---

    // Configuration Section
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(12);
    pdf.text('Test Configuration', col1_x, y_col1);
    y_col1 += 8;

    const configData = {
        'Subject ID': subjectIdEl.value,
        'Age': subjectAgeEl.value,
        'Sex': subjectSexEl.value,
        'Number of Trials': numTrialsEl.value,
        'Stimulus Time (ms)': stimTimeEl.value,
        'ISI (ms)': isiEl.value,
        'Match %': matchPctEl.value,
        'Respond To': respondToEl.value,
        'Number of Colors': numColorsEl.value,
        'Orientation': orientationEl.value,
    };

    pdf.setFontSize(10);
    for (const [label, value] of Object.entries(configData)) {
        pdf.setFont('helvetica', 'bold');
        pdf.text(label + ':', col1_x, y_col1, { maxWidth: colWidth });
        pdf.setFont('helvetica', 'normal');
        pdf.text(String(value), col1_x + 45, y_col1, { maxWidth: colWidth - 45 });
        y_col1 += 6;
    }

    // Performance Summary Section
    y_col1 += 5;
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(12);
    pdf.text('Performance Summary', col1_x, y_col1);
    y_col1 += 8;
    
    // Calculate summary stats from the 'results' array
    const rtList = results.filter(r => r.RT && r.correct).map(r => Number(r.RT));
    const meanRT = rtList.length ? (rtList.reduce((a, b) => a + b, 0) / rtList.length).toFixed(2) : "N/A";
    const correctCount = results.filter(r => r.correct).length;
    const omissions = results.filter(r => r.keyPressed === '').length;
    const commissions = results.filter(r => r.keyPressed && !r.correct).length;

    const summaryData = {
        'Avg. Reaction Time': `${meanRT} ms`,
        'Correct Responses': correctCount,
        'Omissions': omissions,
        'Commissions': commissions,
    };

    pdf.setFontSize(10);
    for (const [label, value] of Object.entries(summaryData)) {
        pdf.setFont('helvetica', 'bold');
        pdf.text(label + ':', col1_x, y_col1);
        pdf.setFont('helvetica', 'normal');
        pdf.text(String(value), col1_x + 45, y_col1);
        y_col1 += 6;
    }

    // Metrics Explained Section
    y_col1 += 5;
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(12);
    pdf.text('Metrics Explained', col1_x, y_col1);
    y_col1 += 6;

    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(9);
    pdf.setTextColor(80);
    pdf.text("Omissions: Failing to respond to a stimulus within the allowed time.", col1_x, y_col1, { maxWidth: colWidth });
    y_col1 += 8;
    pdf.text("Commissions: Responding with the wrong key for a given stimulus.", col1_x, y_col1, { maxWidth: colWidth });

    // --- 4. Right Column (Charts) ---
    const rtImg = rtCanvas.toDataURL("image/png");
    const accImg = accCanvas.toDataURL("image/png");
    const countsImg = countsCanvas.toDataURL("image/png");

    const graphWidth = colWidth;
    const graphHeight = graphWidth / 2; // Maintain 2:1 aspect ratio

    // Reaction Time Chart
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(12);
    pdf.text("Reaction Time Chart", col2_x, y_col2);
    y_col2 += 6;
    pdf.addImage(rtImg, "PNG", col2_x, y_col2, graphWidth, graphHeight);
    y_col2 += graphHeight + 10;

    // Accuracy Chart
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(12);
    pdf.text("Accuracy by Color", col2_x, y_col2);
    y_col2 += 6;
    pdf.addImage(accImg, "PNG", col2_x, y_col2, graphWidth, graphHeight);
    y_col2 += graphHeight + 10;
    
    // Response Counts Chart
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(12);
    pdf.text("Response Counts by Color", col2_x, y_col2);
    y_col2 += 6;
    pdf.addImage(countsImg, "PNG", col2_x, y_col2, graphWidth, graphHeight);

    // --- 5. Footer ---
    const pageCount = pdf.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        pdf.setPage(i);
        pdf.setFontSize(9);
        pdf.setTextColor(150);
        const footerText = `Page ${i} of ${pageCount} | Stroop Test Report`;
        pdf.text(footerText, pageWidth / 2, pageHeight - 10, { align: 'center' });
    }

    // --- 6. Save the PDF ---
    const sid = subjectIdEl.value.trim() || 'subject';
    const fileName = `${sid}_stroop_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')}.pdf`;
    pdf.save(fileName);
}

  // charts rendering (Chart.js)
// MODIFIED RENDERCHARTS TO DISABLE ANIMATIONS ON DEMAND
async function renderCharts(disableAnimation = false) {
    const animationOption = disableAnimation ? { animation: false } : {};

    // --- Chart 1: Reaction Time ---
    const rtList = results.filter(r => r.RT && r.correct).map((r, i) => r.RT);
    const rtLabels = rtList.map((_, i) => `#${i+1}`);
    if (rtChart) rtChart.destroy();
    rtChart = new Chart(rtCanvas.getContext('2d'), {
        type: 'line',
        data: {
            labels: rtLabels,
            datasets: [{
                label: 'RT (ms) - correct',
                data: rtList,
                borderColor: '#3b82f6',
                fill: false
            }]
        },
        options: {
            ...animationOption, // Add this
            responsive: false,
            plugins: {
                title: { display: true, text: 'Reaction Time (Correct Trials)', font: { size: 16 } },
                legend: { display: false }
            },
            scales: { y: { title: { display: true, text: 'RT (ms)' } } }
        }
    });

    // --- Data Prep ---
    const mode = respondToEl.value;
    const usedColors = ALL_COLORS.slice(0, parseInt(numColorsEl.value, 10));
    const colorNames = usedColors.map(c => c.name);

    // --- Chart 2: Accuracy by Color ---
    const accuracyData = colorNames.map(name => {
        const colorResults = results.filter(r => ((mode === 'color') ? r.ink : r.word) === name);
        const correctCount = colorResults.filter(r => r.correct === 1).length;
        const totalCount = colorResults.length;
        return totalCount > 0 ? Math.round((correctCount / totalCount) * 100) : 0;
    });

    if (accChart) accChart.destroy();
    accChart = new Chart(accCanvas.getContext('2d'), {
        type: 'bar',
        data: {
            labels: colorNames,
            datasets: [{
                label: 'Accuracy %',
                data: accuracyData,
                backgroundColor: usedColors.map(c => c.css)
            }]
        },
        options: {
            ...animationOption, // Add this
            responsive: false,
            plugins: {
                title: { display: true, text: 'Accuracy by Color', font: { size: 16 } },
                legend: { display: false }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    title: { display: true, text: 'Accuracy (%)' }
                }
            }
        }
    });

    // --- Chart 3: Response Counts by Color ---
    const countLabels = ['Correct', 'Omissions', 'Commissions'];
    const colorCountDatasets = usedColors.map(color => {
        const colorResults = results.filter(r => ((mode === 'color') ? r.ink : r.word) === color.name);
        const correctCount = colorResults.filter(r => r.correct === 1).length;
        const commissionCount = colorResults.filter(r => r.correct === 0 && r.keyPressed !== '').length;
        const omissionCount = colorResults.filter(r => r.keyPressed === '').length;
        return {
            label: color.name,
            data: [correctCount, commissionCount, omissionCount],
            backgroundColor: color.css
        };
    });

    if (countsChart) countsChart.destroy();
    countsChart = new Chart(countsCanvas.getContext('2d'), {
        type: 'bar',
        data: {
            labels: countLabels,
            datasets: colorCountDatasets
        },
        options: {
            ...animationOption, // Add this
            responsive: false,
            plugins: {
                title: { display: true, text: 'Response Counts by Color', font: { size: 16 } },
                legend: { display: true }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Count' },
                    ticks: { stepSize: 1 }
                }
            }
        }
    });

    return Promise.resolve();
}

// beep
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function beep(freq=440,dur=130){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type='sine'; o.frequency.value = freq; g.gain.setValueAtTime(0.08,audioCtx.currentTime);
    o.start(); o.stop(audioCtx.currentTime + dur/1000);
  }

  // keyboard handlers
  document.addEventListener('keydown', (ev)=>{
    // binding capture flow
    if(bindingsModal.style.display === 'flex' && currentBindingCapture){
      ev.preventDefault();
      if(ev.key === 'Enter'){
        if(lastCapturedKey){
          bindings[currentBindingCapture] = lastCapturedKey;
          currentBindingCapture = null;
          lastCapturedKey = null;
          renderBindingsList();
          rebuildKeybar();
        }
      } else if(ev.key === 'Escape'){
        currentBindingCapture = null; lastCapturedKey = null; renderBindingsList();
      } else {
        lastCapturedKey = normKey(ev.key);
        // update visible preview
        const rows = bindingsList.children;
        for(const row of rows){
          const strong = row.querySelector('strong');
          if(strong && strong.textContent === currentBindingCapture){
            const disp = row.querySelectorAll('div')[1].querySelector('div') || row.querySelectorAll('div')[1];
            if(disp) disp.textContent = lastCapturedKey.toUpperCase();
            break;
          }
        }
      }
      return;
    }
    // if bindings modal open and not capturing - ignore test keys
    if(bindingsModal.style.display === 'flex') return;

    // If test running and awaiting response
    if(awaitingResponse && trials.length && currentIndex >= 0){
      handleResponseKey(ev.key);
    }
  });

  // UI wiring
  openBindingsBtn.addEventListener('click', ()=> openBindings());
  closeBindingsBtn.addEventListener('click', ()=> closeBindings());
  loadDefaultsBtn.addEventListener('click', ()=> { loadDefaultBindings(parseInt(numColorsEl.value,10)); renderBindingsList(); });
  numColorsEl.addEventListener('change', ()=> { loadDefaultBindings(parseInt(numColorsEl.value,10)); rebuildKeybar(); renderBindingsList(); });
  matchPctEl.addEventListener('input', ()=> { matchPctLabel.textContent = matchPctEl.value + '%'; });
  startBtn.addEventListener('click', startTest);
  restartBtn.addEventListener('click', ()=> location.reload());
  csvBtn.addEventListener('click', downloadCSV);
  pdfBtn.addEventListener('click', downloadPDF);
  closePopupBtn.addEventListener('click', ()=> popup.style.display='none');

  // keybar click to simulate
  keybarEl.addEventListener('click', (ev)=>{
    const el = ev.target.closest('.key');
    if(!el) return;
    const color = el.dataset.color;
    const k = bindings[color];
    // if test running and awaiting response, treat as response
    if(awaitingResponse) handleResponseKey(k);
    else { el.classList.add('pressed'); setTimeout(()=>el.classList.remove('pressed'),160); }
  });

  // open/close bindings
  function openBindings(){
    renderBindingsList();
    bindingsModal.style.display = 'flex';
    bindingsModal.style.alignItems = 'center';
    bindingsModal.style.justifyContent = 'center';
    currentBindingCapture = null; lastCapturedKey = null;
  }
  function closeBindings(){
    bindingsModal.style.display = 'none';
    currentBindingCapture = null; lastCapturedKey = null;
  }

  // set up initial defaults
  function init(){
    // fill defaults same as gng-export defaults
    numTrialsEl.value = 30;
    stimTimeEl.value = 1500;
    isiEl.value = 800;
    numColorsEl.value = 3;
    orientationEl.value = 'random';
    matchPctEl.value = 50;
    matchPctLabel.textContent = '50%';
    respondToEl.value = 'color';
    loadDefaultBindings(parseInt(numColorsEl.value,10));
    rebuildKeybar();
    renderBindingsList();
  }

  // expose some functions for debugging
  window._stroop = { startTest, generateTrials, bindings, getResults: ()=>results };

  init();

})();
</script>
</body>
</html>
